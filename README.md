# 🤖 AI Fundamentals - Spring Boot AI Chat Application

A production-ready AI-powered chat application built with **Spring Boot 3**, **Spring AI**, **Spring WebFlux**, and **OpenAI GPT-4**. Features both a reactive web UI and REST API with comprehensive resilience patterns, conversation memory, and clean architecture.

---

## ✨ Key Features

* **Dual Interface**: Web UI and REST API endpoints
* **Reactive Streaming**: Real-time token streaming with Spring WebFlux
* **Conversation Memory**: Persistent chat history across user sessions
* **Resilience Patterns**: Circuit breakers, retries, and fallback mechanisms
* **Clean Architecture**: Domain-driven package structure with clear separation of concerns
* **Production Ready**: Comprehensive error handling, logging, and monitoring

---

## 🏗️ Architecture & Tech Stack

| Layer | Technology | Purpose |
|-------|------------|---------|
| **Web Framework** | Spring Boot 3 + WebFlux | Reactive web application foundation |
| **AI Integration** | Spring AI + OpenAI GPT-4.1-nano | AI chat completions with streaming |
| **UI Layer** | Thymeleaf | Server-side rendered chat interface |
| **API Layer** | REST with reactive streams | Programmatic access via `Flux<String>` |
| **Resilience** | Resilience4j | Circuit breakers, retries, timeouts |
| **Memory** | Spring AI Chat Memory | Conversation persistence per session |
| **Build System** | Gradle 8.13 | Dependency management and build automation |

---

## 🚀 Quick Start

### Prerequisites
- **Java 17+** (OpenJDK recommended)
- **OpenAI API Key** ([Get one here](https://platform.openai.com/api-keys))

### 1. Clone & Setup

```bash
git clone https://github.com/srihari-singuru/ai-fundamentals.git
cd ai-fundamentals
```

### 2. Configure OpenAI API Key

**Environment Variable (Recommended):**
```bash
export OPEN_AI_API_KEY=sk-your-openai-api-key-here
```

**Or update `application.yml`:**
```yaml
spring:
  ai:
    openai:
      api-key: sk-your-openai-api-key-here
```

### 3. Build & Run

```bash
# Build the application
./gradlew build

# Run the application
./gradlew bootRun
```

The application will start on `http://localhost:8080`

---

## 🌐 Usage

### Web Interface
Access the chat UI at: **http://localhost:8080/chat**

- **Interactive Chat**: Type messages and receive AI responses
- **System Prompts**: Customize AI behavior with system messages
- **Conversation Memory**: Chat history persists across page refreshes
- **Reset Option**: Clear conversation history anytime

### REST API
Programmatic access for integrations:

```bash
# Send a chat message
curl -X POST http://localhost:8080/v1/chat-completion \
  -H "Content-Type: application/json" \
  -d '{"message": "Hello, how are you?"}'
```

Response streams back as `Flux<String>` tokens in real-time.

---

## � API Reference

### Entry Points

| Endpoint | Method | Purpose | Controller |
|----------|--------|---------|------------|
| `/chat` | GET | Load chat interface | `ChatWebController` |
| `/chat` | POST | Submit chat message (Web UI) | `ChatWebController` |
| `/v1/chat-completion` | POST | Chat completion API | `ChatApiController` |

### REST API Details

#### POST `/v1/chat-completion`
**Request:**
```json
{
  "message": "Your message here",
  "model": "gpt-4.1-nano",
  "temperature": 0.0
}
```

**Response:** 
- Content-Type: `text/plain`
- Body: Streaming response as `Flux<String>`
- Each token arrives as it's generated by the AI

#### Web UI Endpoints
- **GET `/chat`**: Returns the chat page with conversation history
- **POST `/chat`**: Processes form submission with `ConversationModel`
  - Fields: `systemMessage`, `userMessage`, `reset`

---

## 🛡️ Resilience & Reliability

### Circuit Breaker Pattern
Protects against cascading failures with **Resilience4j**:

```yaml
resilience4j:
  circuitbreaker:
    instances:
      openai:
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
      chatCompletionCB:
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
```

### Retry Strategy
- **Exponential Backoff**: 3 retries with 2-second base delay
- **Jitter**: 40% randomization to prevent thundering herd
- **Selective Retry**: Only on `IOException` and rate limiting (429)

### Fallback Mechanisms
- **API Fallback**: "AI temporarily unavailable" message
- **Web UI Fallback**: Graceful error page with retry options
- **Comprehensive Logging**: All failures logged with context

---

## 🏛️ Project Structure

### Clean Architecture Implementation

```
src/main/java/com/srihari/ai/
├── AiFundamentalsApplication.java          # Spring Boot main class
├── configuration/
│   └── ChatMemoryConfig.java              # Chat memory configuration
├── controller/
│   ├── api/
│   │   └── ChatApiController.java          # REST API endpoints
│   └── web/
│       └── ChatWebController.java          # Web UI endpoints
├── model/
│   ├── dto/
│   │   └── ChatCompletionRequest.java      # API request DTO
│   └── view/
│       ├── ChatMessageView.java            # Chat display model
│       └── ConversationModel.java          # Web form model
├── service/
│   ├── chat/
│   │   ├── ApiChatService.java             # API business logic
│   │   └── WebChatService.java             # Web UI business logic
│   ├── integration/
│   │   └── OpenAiChatClient.java           # OpenAI API client
│   ├── MemoryService.java                  # Conversation persistence
│   ├── PromptService.java                  # AI prompt handling
│   └── ViewMappingService.java             # View model mapping
└── util/
    └── SafeEvaluator.java                  # Safe evaluation utilities
```

### Design Principles

- **Domain-Driven Design**: Packages organized by business domain
- **Separation of Concerns**: Clear boundaries between layers
- **Dependency Injection**: All components properly wired via Spring
- **Reactive Programming**: Non-blocking I/O throughout the stack
- **Single Responsibility**: Each class has one clear purpose

---

## 🔧 Configuration

### Application Properties
Key configuration in `application.yml`:

```yaml
spring:
  application:
    name: ai-fundamentals
  ai:
    openai:
      api-key: ${OPEN_AI_API_KEY}
      chat:
        options:
          model: gpt-4.1-nano
          temperature: 0.0

management:
  health:
    circuitbreakers:
      enabled: true
```

### Environment Variables
- `OPEN_AI_API_KEY`: Your OpenAI API key (required)

---

## 🧪 Development

### Running Tests
```bash
./gradlew test
```

### Development Mode
```bash
./gradlew bootRun --args='--spring.profiles.active=dev'
```

### Building for Production
```bash
./gradlew build
java -jar build/libs/ai-fundamentals-0.0.1-SNAPSHOT.jar
```

---

## 📊 Monitoring & Health

### Health Checks
- **Application Health**: `GET /actuator/health`
- **Circuit Breaker Status**: Included in health endpoint
- **Custom Health Indicators**: Circuit breaker states

### Logging
- **Structured Logging**: JSON format for production
- **Request Tracing**: Full request/response logging
- **Error Context**: Comprehensive error information

---

## 🚀 Production Deployment

### Docker Support
```dockerfile
FROM openjdk:17-jdk-slim
COPY build/libs/ai-fundamentals-0.0.1-SNAPSHOT.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

### Environment Setup
```bash
# Production environment variables
export OPEN_AI_API_KEY=your-production-key
export SPRING_PROFILES_ACTIVE=prod
export SERVER_PORT=8080
```

---

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/amazing-feature`
3. Commit changes: `git commit -m 'Add amazing feature'`
4. Push to branch: `git push origin feature/amazing-feature`
5. Open a Pull Request

---

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## 🙏 Acknowledgments

- **Spring AI Team** for the excellent AI integration framework
- **OpenAI** for providing powerful language models
- **Spring Boot Team** for the reactive web framework
- **Resilience4j** for robust resilience patterns