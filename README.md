# ğŸ¤– AI Fundamentals - Spring Boot AI Chat Application

A production-ready AI-powered chat application built with **Spring Boot 3**, **Spring AI**, **Spring WebFlux**, and **OpenAI GPT-4**. Features both a reactive web UI and REST API with comprehensive resilience patterns, conversation memory, and clean architecture.

---

## âœ¨ Key Features

* **Dual Interface**: Web UI and REST API endpoints
* **Reactive Streaming**: Real-time token streaming with Spring WebFlux
* **Conversation Memory**: Persistent chat history across user sessions
* **Resilience Patterns**: Circuit breakers, retries, and fallback mechanisms
* **Clean Architecture**: Domain-driven package structure with clear separation of concerns
* **Production Ready**: Comprehensive error handling, logging, and monitoring

---

## ğŸ—ï¸ Architecture & Tech Stack

| Layer | Technology | Purpose |
|-------|------------|---------|
| **Web Framework** | Spring Boot 3 + WebFlux | Reactive web application foundation |
| **AI Integration** | Spring AI + OpenAI GPT-4.1-nano | AI chat completions with streaming |
| **UI Layer** | Thymeleaf | Server-side rendered chat interface |
| **API Layer** | REST with reactive streams | Programmatic access via `Flux<String>` |
| **Resilience** | Resilience4j | Circuit breakers, retries, timeouts |
| **Memory** | Spring AI Chat Memory | Conversation persistence per session |
| **Build System** | Gradle 8.13 | Dependency management and build automation |

---

## ğŸš€ Quick Start

### Prerequisites
- **Java 17+** (OpenJDK recommended)
- **OpenAI API Key** ([Get one here](https://platform.openai.com/api-keys))

### 1. Clone & Setup

```bash
git clone https://github.com/srihari-singuru/ai-fundamentals.git
cd ai-fundamentals
```

### 2. Configure OpenAI API Key

**Environment Variable (Recommended):**
```bash
export OPEN_AI_API_KEY=sk-your-openai-api-key-here
```

**Or update `application.yml`:**
```yaml
spring:
  ai:
    openai:
      api-key: sk-your-openai-api-key-here
```

### 3. Build & Run

```bash
# Build the application
./gradlew build

# Run the application
./gradlew bootRun
```

The application will start on `http://localhost:8080`

---

## ğŸŒ Usage

### Web Interface
Access the chat UI at: **http://localhost:8080/chat**

- **Interactive Chat**: Type messages and receive AI responses
- **System Prompts**: Customize AI behavior with system messages
- **Conversation Memory**: Chat history persists across page refreshes
- **Reset Option**: Clear conversation history anytime

### REST API
Programmatic access for integrations:

```bash
# Send a chat message
curl -X POST http://localhost:8080/v1/chat-completion \
  -H "Content-Type: application/json" \
  -d '{"message": "Hello, how are you?"}'
```

Response streams back as `Flux<String>` tokens in real-time.

---

## ï¿½ API Reference

### Entry Points

| Endpoint | Method | Purpose | Controller |
|----------|--------|---------|------------|
| `/chat` | GET | Load chat interface | `ChatWebController` |
| `/chat` | POST | Submit chat message (Web UI) | `ChatWebController` |
| `/v1/chat-completion` | POST | Chat completion API | `ChatApiController` |

### REST API Details

#### POST `/v1/chat-completion`
**Request:**
```json
{
  "message": "Your message here",
  "model": "gpt-4.1-nano",
  "temperature": 0.0
}
```

**Response:** 
- Content-Type: `text/plain`
- Body: Streaming response as `Flux<String>`
- Each token arrives as it's generated by the AI

#### Web UI Endpoints
- **GET `/chat`**: Returns the chat page with conversation history
- **POST `/chat`**: Processes form submission with `ConversationModel`
  - Fields: `systemMessage`, `userMessage`, `reset`

---

## ğŸ›¡ï¸ Resilience & Reliability

### Circuit Breaker Pattern
Protects against cascading failures with **Resilience4j**:

```yaml
resilience4j:
  circuitbreaker:
    instances:
      openai:
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
      chatCompletionCB:
        slidingWindowSize: 10
        minimumNumberOfCalls: 5
        failureRateThreshold: 50
        waitDurationInOpenState: 10s
```

### Retry Strategy
- **Exponential Backoff**: 3 retries with 2-second base delay
- **Jitter**: 40% randomization to prevent thundering herd
- **Selective Retry**: Only on `IOException` and rate limiting (429)

### Fallback Mechanisms
- **API Fallback**: "AI temporarily unavailable" message
- **Web UI Fallback**: Graceful error page with retry options
- **Comprehensive Logging**: All failures logged with context

---

## ğŸ›ï¸ Project Structure

### Clean Architecture Implementation

```
src/main/java/com/srihari/ai/
â”œâ”€â”€ AiFundamentalsApplication.java          # Spring Boot main class
â”œâ”€â”€ configuration/
â”‚   â””â”€â”€ ChatMemoryConfig.java              # Chat memory configuration
â”œâ”€â”€ controller/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ ChatApiController.java          # REST API endpoints
â”‚   â””â”€â”€ web/
â”‚       â””â”€â”€ ChatWebController.java          # Web UI endpoints
â”œâ”€â”€ model/
â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â””â”€â”€ ChatCompletionRequest.java      # API request DTO
â”‚   â””â”€â”€ view/
â”‚       â”œâ”€â”€ ChatMessageView.java            # Chat display model
â”‚       â””â”€â”€ ConversationModel.java          # Web form model
â”œâ”€â”€ service/
â”‚   â”œâ”€â”€ chat/
â”‚   â”‚   â”œâ”€â”€ ApiChatService.java             # API business logic
â”‚   â”‚   â””â”€â”€ WebChatService.java             # Web UI business logic
â”‚   â”œâ”€â”€ integration/
â”‚   â”‚   â””â”€â”€ OpenAiChatClient.java           # OpenAI API client
â”‚   â”œâ”€â”€ MemoryService.java                  # Conversation persistence
â”‚   â”œâ”€â”€ PromptService.java                  # AI prompt handling
â”‚   â””â”€â”€ ViewMappingService.java             # View model mapping
â””â”€â”€ util/
    â””â”€â”€ SafeEvaluator.java                  # Safe evaluation utilities
```

### Design Principles

- **Domain-Driven Design**: Packages organized by business domain
- **Separation of Concerns**: Clear boundaries between layers
- **Dependency Injection**: All components properly wired via Spring
- **Reactive Programming**: Non-blocking I/O throughout the stack
- **Single Responsibility**: Each class has one clear purpose

---

## ğŸ”§ Configuration

### Application Properties
Key configuration in `application.yml`:

```yaml
spring:
  application:
    name: ai-fundamentals
  ai:
    openai:
      api-key: ${OPEN_AI_API_KEY}
      chat:
        options:
          model: gpt-4.1-nano
          temperature: 0.0

management:
  health:
    circuitbreakers:
      enabled: true
```

### Environment Variables
- `OPEN_AI_API_KEY`: Your OpenAI API key (required)

---

## ğŸ§ª Development

### Running Tests
```bash
./gradlew test
```

### Development Mode
```bash
./gradlew bootRun --args='--spring.profiles.active=dev'
```

### Building for Production
```bash
./gradlew build
java -jar build/libs/ai-fundamentals-0.0.1-SNAPSHOT.jar
```

---

## ğŸ“Š Monitoring & Health

### Health Checks
- **Application Health**: `GET /actuator/health`
- **Circuit Breaker Status**: Included in health endpoint
- **Custom Health Indicators**: Circuit breaker states

### Logging
- **Structured Logging**: JSON format for production
- **Request Tracing**: Full request/response logging
- **Error Context**: Comprehensive error information

---

## ğŸš€ Production Deployment

### Docker Support
```dockerfile
FROM openjdk:17-jdk-slim
COPY build/libs/ai-fundamentals-0.0.1-SNAPSHOT.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

### Environment Setup
```bash
# Production environment variables
export OPEN_AI_API_KEY=your-production-key
export SPRING_PROFILES_ACTIVE=prod
export SERVER_PORT=8080
```

---

## ğŸ¤ Contributing

1. Fork the repository
2. Create a feature branch: `git checkout -b feature/amazing-feature`
3. Commit changes: `git commit -m 'Add amazing feature'`
4. Push to branch: `git push origin feature/amazing-feature`
5. Open a Pull Request

---

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## ğŸ™ Acknowledgments

- **Spring AI Team** for the excellent AI integration framework
- **OpenAI** for providing powerful language models
- **Spring Boot Team** for the reactive web framework
- **Resilience4j** for robust resilience patterns